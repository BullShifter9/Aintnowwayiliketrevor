-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Constants for prediction
local PREDICTION_SETTINGS = {
    BASE_MULTIPLIER = 0.15,
    VERTICAL_MULTIPLIER = 0.35,
    MAX_DISTANCE = 100,
    MIN_VELOCITY = 0.1,
    GRAVITY_COMPENSATION = 0.7,
    PING_MULTIPLIER = 1.2,
    ACCELERATION_WEIGHT = 0.8,
    DIRECTION_WEIGHT = 1.2,
    JUMP_PREDICTION = 0.4,
    VELOCITY_DAMPING = 0.85
}

-- Advanced prediction functions
local function calculateVelocityFactor(velocity)
    local speed = velocity.Magnitude
    local normalizedSpeed = math.clamp(speed / 30, 0, 1)
    return math.pow(normalizedSpeed, 0.7) * PREDICTION_SETTINGS.VELOCITY_DAMPING
end

local function calculateDirectionWeight(moveDirection, lookVector)
    local alignment = moveDirection:Dot(lookVector)
    return 1 + (alignment * PREDICTION_SETTINGS.DIRECTION_WEIGHT)
end

local function calculatePingCompensation(ping)
    local normalizedPing = math.clamp(ping / 200, 0, 1)
    return 1 + (normalizedPing * PREDICTION_SETTINGS.PING_MULTIPLIER)
end

local function calculateGravityCompensation(velocity)
    local verticalSpeed = velocity.Y
    if verticalSpeed > 0 then
        return verticalSpeed * PREDICTION_SETTINGS.JUMP_PREDICTION
    else
        return verticalSpeed * PREDICTION_SETTINGS.GRAVITY_COMPENSATION
    end
end

local function getPredictedPosition(player, shootOffset)
    if not player or not player.Character then
        return nil, "No target found"
    end
    
    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character:FindFirstChild("UpperTorso")
    
    if not humanoid or not hrp then
        return nil, "Invalid character parts"
    end
    
    -- Get base values
    local currentPosition = hrp.Position
    local velocity = hrp.AssemblyLinearVelocity
    local moveDirection = humanoid.MoveDirection
    local lookVector = hrp.CFrame.LookVector
    local ping = Players.LocalPlayer:GetNetworkPing() * 1000
    
    -- Calculate advanced prediction factors
    local velocityFactor = calculateVelocityFactor(velocity)
    local directionWeight = calculateDirectionWeight(moveDirection, lookVector)
    local pingCompensation = calculatePingCompensation(ping)
    local gravityOffset = calculateGravityCompensation(velocity)
    
    -- Calculate acceleration
    local acceleration = Vector3.new(
        math.sign(velocity.X) * velocityFactor,
        gravityOffset,
        math.sign(velocity.Z) * velocityFactor
    )
    
    -- Calculate final prediction
    local baseOffset = velocity * shootOffset * PREDICTION_SETTINGS.BASE_MULTIPLIER
    local directionOffset = moveDirection * shootOffset * directionWeight
    local accelerationOffset = acceleration * shootOffset * PREDICTION_SETTINGS.ACCELERATION_WEIGHT
    local verticalOffset = Vector3.new(0, gravityOffset * PREDICTION_SETTINGS.VERTICAL_MULTIPLIER, 0)
    
    local predictedPosition = currentPosition +
        baseOffset +
        directionOffset +
        accelerationOffset +
        verticalOffset
    
    -- Apply ping compensation
    predictedPosition = predictedPosition + (velocity * pingCompensation * 0.1)
    
    -- Clamp prediction distance
    local predictionDistance = (predictedPosition - currentPosition).Magnitude
    if predictionDistance > PREDICTION_SETTINGS.MAX_DISTANCE then
        local direction = (predictedPosition - currentPosition).Unit
        predictedPosition = currentPosition + direction * PREDICTION_SETTINGS.MAX_DISTANCE
    end
    
    -- Verify line of sight
    local ray = Ray.new(currentPosition, predictedPosition - currentPosition)
    local hit, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {character})
    
    if hit then
        predictedPosition = hitPosition
    end
    
    return predictedPosition
end

local lastPredictions = {}
local function smoothPrediction(player, rawPrediction)
    if not lastPredictions[player] then
        lastPredictions[player] = rawPrediction
        return rawPrediction
    end
    
    local smoothFactor = 0.7
    local smoothedPrediction = lastPredictions[player]:Lerp(rawPrediction, smoothFactor)
    lastPredictions[player] = smoothedPrediction
    
    return smoothedPrediction
end
-- Create ScreenGui with better protection
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = game:GetService("HttpService"):GenerateGUID(false)
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global

-- Try to use Synapse X protection if available
if syn then
    syn.protect_gui(ScreenGui)
end

ScreenGui.Parent = game:GetService("CoreGui")

-- Create fancier loading frame with blur effect
local LoadingFrame = Instance.new("Frame")
LoadingFrame.Size = UDim2.new(1, 0, 1, 0)
LoadingFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
LoadingFrame.BackgroundTransparency = 0.3
LoadingFrame.Parent = ScreenGui

-- Add blur effect
local BlurEffect = Instance.new("BlurEffect")
BlurEffect.Size = 0
BlurEffect.Parent = game:GetService("Lighting")

-- Create gradient
local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(40, 40, 40)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 30, 30))
})
UIGradient.Parent = LoadingFrame

-- Enhanced loading circle creation
local function createLoadingCircle(size, speed, offset, color)
    local circleContainer = Instance.new("Frame")
    circleContainer.Size = UDim2.new(0, size, 0, size)
    circleContainer.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
    circleContainer.BackgroundTransparency = 1
    circleContainer.Parent = LoadingFrame
    
    local circle = Instance.new("ImageLabel")
    circle.Size = UDim2.new(1, 0, 1, 0)
    circle.BackgroundTransparency = 1
    circle.Image = "rbxassetid://4965945816"
    circle.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
    circle.ImageTransparency = 0.2
    circle.Parent = circleContainer
    
    -- Add glow effect
    local glow = Instance.new("ImageLabel")
    glow.Size = UDim2.new(1.2, 0, 1.2, 0)
    glow.Position = UDim2.new(-0.1, 0, -0.1, 0)
    glow.BackgroundTransparency = 1
    glow.Image = "rbxassetid://4965945816"
    glow.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
    glow.ImageTransparency = 0.7
    glow.Parent = circle
    
    -- Animate both rotation and pulse
    local rotation = offset or 0
    spawn(function()
        while LoadingFrame.Visible do
            rotation = rotation + speed
            circleContainer.Rotation = rotation
            
            -- Pulse animation
            local pulseSize = math.sin(tick() * 2) * 0.1 + 1
            circle.Size = UDim2.new(pulseSize, 0, pulseSize, 0)
            glow.Size = UDim2.new(pulseSize * 1.2, 0, pulseSize * 1.2, 0)
            
            task.wait()
        end
    end)
    
    return circleContainer
end

-- Create enhanced loading circles with different colors
local circle1 = createLoadingCircle(100, 2, 0, Color3.fromRGB(255, 100, 100))
local circle2 = createLoadingCircle(80, -3, 45, Color3.fromRGB(100, 255, 100))
local circle3 = createLoadingCircle(60, 4, 90, Color3.fromRGB(100, 100, 255))

-- Create animated loading text
local LoadingText = Instance.new("TextLabel")
LoadingText.Size = UDim2.new(0, 200, 0, 50)
LoadingText.Position = UDim2.new(0.5, -100, 0.6, -25)
LoadingText.BackgroundTransparency = 1
LoadingText.Text = "Loading MM2 Helper..."
LoadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
LoadingText.TextSize = 20
LoadingText.Font = Enum.Font.GothamBold
LoadingText.Parent = LoadingFrame

-- Animated dots for loading text
spawn(function()
    local dots = ""
    while LoadingFrame.Visible do
        dots = dots .. "."
        if #dots > 3 then dots = "" end
        LoadingText.Text = "Loading MM2 Script" .. dots
        wait(0.5)
    end
end)

-- Add version text
local VersionText = Instance.new("TextLabel")
VersionText.Size = UDim2.new(0, 200, 0, 20)
VersionText.Position = UDim2.new(0.5, -100, 0.6, 10)
VersionText.BackgroundTransparency = 1
VersionText.Text = "v2.0.0"
VersionText.TextColor3 = Color3.fromRGB(200, 200, 200)
VersionText.TextSize = 14
VersionText.Font = Enum.Font.GothamMedium
VersionText.Parent = LoadingFrame

-- Create shadow effect
local Shadow = Instance.new("ImageLabel")
Shadow.Size = UDim2.new(1.1, 0, 1.1, 0)
Shadow.Position = UDim2.new(-0.05, 0, -0.05, 0)
Shadow.BackgroundTransparency = 1
Shadow.Image = "rbxassetid://5028857084"
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.8
Shadow.Parent = LoadingFrame
